'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*!
 * pytils
 * Copyright (c) 2016 heyderpd <heyderpd@gmail.com>
 * ISC Licensed
*/

/* TYPE */

var type = exports.type = function type(obj) {
  if (obj === null) {
    return 'null';
  }
  if (obj === undefined) {
    return 'undefined';
  }
  var _typeOf = typeof obj === 'undefined' ? 'undefined' : _typeof(obj);
  switch (_typeOf) {
    case 'function':
      return 'function';

    case 'number':
      return isNaN(obj) ? 'NaN' : 'number';

    case 'object':
      var _type = obj.constructor;
      if (_type === Object) {
        return 'object';
      }
      if (_type === Array) {
        return 'array';
      }

    default:
      return _typeOf;
  }
};

var isType = exports.isType = function isType(obj, _type) {
  return type(obj) === _type;
};

var isString = exports.isString = function isString(obj) {
  return isType(obj, 'string');
};

var isNumber = exports.isNumber = function isNumber(obj) {
  return isType(obj, 'number');
};

var isArray = exports.isArray = function isArray(obj) {
  return isType(obj, 'array');
};

var isObject = exports.isObject = function isObject(obj) {
  return isType(obj, 'object');
};

var isFunction = exports.isFunction = function isFunction(obj) {
  return isType(obj, 'function');
};

var isAOF = exports.isAOF = function isAOF(obj) {
  return obj !== null && ['object', 'function'].indexOf(typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) >= 0;
};

var isUN = exports.isUN = function isUN(obj) {
  return obj === undefined || obj === null;
};

var isNull = exports.isNull = function isNull(obj) {
  return obj === null;
};

var isUndefined = exports.isUndefined = function isUndefined(obj) {
  return obj === undefined;
};

/* TYPE */
/* RAMDA LIKE */

var getArgs = function getArgs(fx) {
  return function () {
    var args = [];
    for (var key in arguments) {
      args.push(arguments[key]);
    }
    return fx(args);
  };
};

var composeDown = exports.composeDown = getArgs(function (funcs) {
  return function (input) {
    return funcs.reduce(function (obj, fx) {
      return fx(obj);
    }, input);
  };
});

var compose = exports.compose = getArgs(function (funcs) {
  return function (input) {
    return funcs.reduceRight(function (obj, fx) {
      return fx(obj);
    }, input);
  };
});

var curry = exports.curry = function curry(func) {
  return getArgs(function (args) {
    return args.reduce(function (fx, arg) {
      return fx(arg);
    }, func);
  });
};

var path = exports.path = curry(function (path) {
  return function (obj) {
    return path.reduce(function (acc, item) {
      return !isUN(acc) ? acc[item] : undefined;
    }, obj);
  };
});

var mapx = exports.mapx = function mapx(list, func) {
  switch (type(list)) {
    case 'array':
      return list.map(func);

    case 'object':
    case 'function':
      return keys(list).map(function (key) {
        return func(list[key], key);
      });

    default:
      return undefined;
  }
};

var map = exports.map = curry(function (func) {
  return function (list) {
    return mapx(list, func);
  };
});

var reduce = exports.reduce = function reduce(func, obj) {
  return function (list) {
    return isArray(list) ? list.reduce(func, obj) : isObject(list) ? keys(list).reduce(function (obj, key) {
      return func(obj, list[key], key);
    }, obj) : undefined;
  };
};

var uniqWith = exports.uniqWith = function uniqWith(comparator, list) {
  var outputList = [];
  map(function (itemA) {
    var equals = map(function (itemB) {
      return comparator(itemA, itemB);
    })(outputList).filter(function (item) {
      return item;
    });

    equals && equals.length === 0 && outputList.push(itemA);
  })(list);
  return outputList;
};

var uniq = exports.uniq = function uniq(list) {
  var New = [];
  list.map(function (item) {
    return New.indexOf(item) < 0 ? New.push(item) : null;
  });
  return New;
};

/* RAMDA LIKE */
/* REGEX */

var toArray = exports.toArray = function toArray(match) {
  return match.slice(1, match.length);
};

var unmountRegEx = exports.unmountRegEx = function unmountRegEx(RegEX) {
  RegEX = RegEX.toString();
  var getFlags = /\/(\w*)$/m;

  var _toArray = toArray(getFlags.exec(RegEX)),
      _toArray2 = _slicedToArray(_toArray, 1),
      flags = _toArray2[0];

  RegEX = RegEX.substr(1, RegEX.length).replace(getFlags, '');
  return [RegEX, flags];
};

var reCompile = exports.reCompile = function reCompile(RX) {
  var _unmountRegEx = unmountRegEx(RX),
      _unmountRegEx2 = _slicedToArray(_unmountRegEx, 2),
      RegEX = _unmountRegEx2[0],
      flags = _unmountRegEx2[1];

  return new RegExp(RegEX, flags);
};

var ifMatch = exports.ifMatch = function ifMatch(RX, fx) {
  var regX = reCompile(RX);
  return function (word) {
    regX.lastIndex = 0;
    var match = void 0;
    if (match = regX.exec(word)) {
      return fx(toArray(match));
    }
  };
};

var whileMatch = exports.whileMatch = function whileMatch(RX, fx) {
  var regX = reCompile(RX);
  return function (word) {
    regX.lastIndex = 0;
    var result = [];
    var match = void 0;
    while (match = regX.exec(word)) {
      result.push(fx(toArray(match)));
    }
    return result;
  };
};

/* REGEX */
/* PYTILS */

var arrayDiff = exports.arrayDiff = function arrayDiff(list, compare) {
  if (length(compare) <= 0) {
    return copy(list);
  }
  if (length(list) <= 0) {
    return copy(compare);
  }
  var obj = toObject(list);
  compare.map(function (k) {
    return delete obj[k];
  });
  return keys(obj);
};

var toObject = exports.toObject = function toObject(input) {
  if (isArray(input) && length(v) <= 0) {
    return {};
  }
  return input.reduce(function (obj, v, k) {
    obj[v] = copy(k);
    return obj;
  }, {});
};

var invertObj = exports.invertObj = function invertObj(input) {
  return reduce(function (obj, val, key) {
    obj[val] = key;
    return obj;
  }, {})(input);
};

var ojbFromVals = exports.ojbFromVals = function ojbFromVals(arrKeys) {
  return arrKeys.reduce(function (obj, val) {
    obj[val] = val;
    return obj;
  }, {});
};

var translate = exports.translate = curry(function (dictionary) {
  return function (original) {
    return reduce(function (obj, ori, des) {
      obj[des] = path([ori], original);
      return obj;
    }, {})(dictionary);
  };
});

var uniqObject = exports.uniqObject = function uniqObject(A, B) {
  return compose(function (arr) {
    return arr && arr.length === 1 && arr[0] === true;
  }, uniq, map(function (key) {
    return path([key], A) === path([key], B);
  }), keys)(A);
};

var ifThrow = exports.ifThrow = function ifThrow(Throw, text) {
  if (Throw) {
    throw text;
  }
};

var essentialDict = {
  'UN': isUN,
  'AOF': isAOF,
  'string': isString,
  'number': isNumber,
  'array': isArray,
  'object': isObject,
  'null': isNull,
  'undefined': isUndefined,
  'function': isFunction
};

var essentialErro = function essentialErro(name, type) {
  return 'pytils: Params[x].' + name + ' is a essential! and need to be a valid \'' + type + '\'.';
};

var isEssential = exports.isEssential = function isEssential(moduleName) {
  return function (Params) {
    var getErro = function getErro(name, type) {
      return moduleName + ': ' + name + ' is a essential! and need to be a valid \'' + type + '\'.';
    };
    mapx(Params, function (data) {
      var name = path([0], keys(data));
      var param = path([name], data);
      var _type = path(['t'], data) || path(['type'], data);
      var _func = essentialDict[_type];
      var func = _func ? _func : path(['f'], data) || path(['func'], data);

      ifThrow(!isString(_type), essentialErro('type', 'string'));
      ifThrow(!isFunction(func), essentialErro('func', 'type function'));
      ifThrow(!func(param), getErro(name, _type));
    });
  };
};

/* PYTILS */
/* OBJECT */

var _keys = function () {
  var ObjectHas = path(['prototype', 'hasOwnProperty'], Object);

  return function (obj) {
    if (isAOF(obj)) {
      var props = [];
      for (var p in obj) {
        props.push(p);
      }
      var has = ObjectHas ? ObjectHas : path(['hasOwnProperty'], obj);
      return isFunction(has) ? props.filter(function (p) {
        return has.call(obj, p);
      }) : props;
    }
    return [];
  };
}();

var scopedObject = exports.scopedObject = function scopedObject() {
  var obj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var fxs = arguments[1];
  return _keys(fxs).reduce(function (acc, key) {
    var value = fxs[key];
    acc[key] = value(obj);
    return acc;
  }, obj);
};

var keys = exports.keys = function keys(obj) {
  switch (type(obj)) {
    case 'number':
      obj = String(obj);

    case 'string':
      obj = obj.split('');

    case 'array':
    case 'object':
    case 'function':
      return _keys(obj);

    case 'null':
    case 'undefined':
    default:
      return [];
  }
};

var values = exports.values = function values(obj) {
  switch (type(obj)) {
    case 'number':
      return String(obj).split('').map(function (n) {
        return parseInt(n);
      });

    case 'string':
      return obj.split('');

    case 'object':
    case 'function':
      return map(function (val) {
        return val;
      }, obj);

    case 'array':
      return obj;

    case 'null':
    case 'undefined':
    default:
      return [];
  }
};

var _copy = exports._copy = function _copy(obj) {
  var R = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

  ifThrow(R++ > 42, 'Limit recursive exceeded in pytils.copyObject');

  if (isAOF(obj)) {
    var nObj = new obj.constructor();
    map(function (v, k) {
      return nObj[k] = _copy(v, R);
    }, obj);
    return nObj;
  }

  return obj;
};

var copy = exports.copy = function copy(obj) {
  return _copy(obj);
};

var hasProp = exports.hasProp = function hasProp(obj, item) {
  return isAOF(obj) ? keys(obj).indexOf(item) >= 0 : false;
};

var length = exports.length = function length(obj) {
  switch (type(obj)) {
    case 'function':
      if (hasProp(obj, 'length')) {
        return obj.length;
      }

    case 'number':
    case 'object':
      return keys(obj).length;

    case 'string':
    case 'array':
      return obj.length;

    case 'null':
    case 'undefined':
    default:
      return -1;
  }
};

/* OBJECT */