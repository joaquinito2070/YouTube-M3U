***
const tagCatcher = /<([^>]+)>/gim
g1 = '/div a=2/'

const slashCatcher = /^(\/)?([\w\W]*?)(\/)?$/
g1 = '/'
g2 = 'div a=2'
g3 = '/'

if g1: [is close tag]
  if tag close: [find a uper open tag] FAIL!!!
    if found:
      > link tags
    else:
      > close this tag

find tag:
  memo all opens and closes
  read all closes from 1ยบ to last
  each item: find first open above 

if g3: [is tag with close]
  > close this tag

if anyone: [is tag and no close]
  > leave open

const paramCatcher = /(?:([^ ?=]+))(?:="((?:\\"|.)+?)")?/gim
g1 = 'param-name'
g2 = 'param-value'
> take first param as a tag name

***
create list of tags [ open, open-close, close ]
find pure-text values and and create new list of [ open, open-close, close, pure-text ]
filter close list from it store 
reverse all list or read reverse to find whatever
do [ find tag ] each intersection of link the inner nodes will be a inner node [ AND close all incomplete nodes in end ]

***
[ help to use regex ]
To reset it manually, set the lastIndex property.
reg.lastIndex = 0;

BUT if go to the end of exec will reset too
var re = /\d/gim
var f = param => {
  while (match = re.exec(param)) {
    console.log(match, re.lastIndex)
  }
}


/*******************************/


/* regex */
const tagCatcher = /<(\/)?([^ =>]+)([^>]*?)(\/)?>/gim
const paramCatcher = /(?:([^ ?=]+))(?:="((?:\\"|.)+?)")?/gim

/* create object from match */
const _tryPushNode = Nodes => match => {
  const tag = match[1] !== undefined ? match[1] : ''
  if (tag) {
    const node = {
        tag: tag,
      param: match[2] !== undefined ? match[2] : '',
      start: match.index,
        end: Pattern.lastIndex
    }
    match[4] !== undefined
      ? ( node.linked = true )
      : ( match[1] !== undefined
            ? node.close = true
            : node.open = true )
    Nodes.push(node)
  }
}

/* erros */
const erros = {
  forcedCloseTag: [],
  lostCloseTag: []
}

const isForcedCloseTag = (openNode, closeNode) => {
  if (!closeNode && !openNode.linked && openNode.open){
    erros.forcedCloseTag.push({
      tag: openNode.tag,
      start: openNode.start,
      end: openNode.end
    })
  }
}

const isLostCloseTag = closeNode => {
  if (closeNode){
    erros.lostCloseTag.push({
      tag: closeNode.tag,
      start: closeNode.start,
      end: closeNode.end
    })
  }
}

/* functions */
const getAllTags = html => {
  const Nodes = []
  const tryPushNode = _tryPushNode(Nodes)
  let match
  while (match = tagCatcher.exec(html)) {
    tryPushNode(match)
  }
  return Nodes
}

const addAllPureTexts = (Nodes, html) => {
  let fullNodes = [], before = 0, text = ''
  Nodes
    .concat({ start: html.length })
    .map(node => {
      text = html.substr(before, node.start -before)
      text ? fullNodes.push(text) : null
      before = before.end
      fullNodes.push(node)
    })
  fullNodes.pop()
  return fullNodes
}

const oneMapToFilter = Nodes => {
  let closes = [], noCloses = []
  Nodes.map(
    (n, k) => n.close
      ? closes[k] = n
      : noCloses[k] = n)
  return { closes, noCloses }
}

const _findOpen = noCloses => (tag, key) => {
  let node
  for (let kOpen = key; kOpen >= 0; kOpen--) {
    node = noCloses[kOpen]
    if (node && node.open && node.tag === tag) {
      return kOpen
    }
  }
  return false
}

const createNode = (openNode, closeNode) => {
  isForcedCloseTag(openNode, closeNode)
  delete openNode.open
  delete openNode.linked
  closeNode && (openNode.end = closeNode.end)
  openNode.link = {
    father: null,
    child: []
  }
  return openNode
}

const _forceCreateNode = (list, father) => child => {
  if (child) {
    if (typeof child === 'object') {
      if (!child.link) {
        child = createNode(child)
      }
      child.link.father = father
    }
    father.link.child.push(child)
    pushList(child)
  }
}

const _linkNodes = (pushList, closes, noCloses) => (kOpen, kClose) => {
  const father = createNode(noCloses[kOpen], closes[kClose])
  pushList(father)
  const forceCreateNode = _forceCreateNode(pushList, father)
  for (let key = kOpen +1; key <= kClose; key++) {
    forceCreateNode(noCloses[key])
    delete noCloses[key]
    delete closes[key]
  }
  noCloses[kOpen] = father
}

const mountTree = (pushList, Nodes) => {
  let kOpen
  const { closes, noCloses } = oneMapToFilter(Nodes)
  const findOpen = _findOpen(noCloses)
  const linkNodes = _linkNodes(pushList, closes, noCloses)
  closes.map(
    (n, kClose) => {
      kOpen = findOpen(closeNode.tag, kClose)
      if (kOpen !== false) {
        linkNodes(kOpen, kClose)
      } else {
        isLostCloseTag(closes[kClose])
      }
    }
  )
}

const _pushList = list => node => list.push(node)

export const mountRoot = html => {
  const list = []
  const pushList = _pushList(list)
  const tree = mountTree(
    pushList,
    addAllPureTexts(
      getAllTags(html),
      html))
  return {
    file: html,
    list: list,
    tree: tree
  }
}
